<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body{
    font-size: 1.2em;
    font-family: serif;
  }
  .key{
    display: inline-block;
    width: 500px;
    color: #34a21a;
    font-weight: 700;
  }
  .ui-section{
    height: 40px;
  }
  .input {
    -webkit-appearance: none;
    width: 40%;
    height: 25px;
    background: #d3d3d3;
    outline: none;
    opacity: 0.7;
    -webkit-transition: .2s;
    transition: opacity .2s;
  }
  .input:hover {
    opacity: 1;
  }
  .input-button{
    color: #4CAF50;
    font-size: 1.0em;
    font-weight: 600;
    border: none;
    margin-left: 2px;
  }
  .input-button:active{
    background-color: #5b5b5b;
  }
  .slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 25px;
    height: 25px;
    background: #4CAF50;
    cursor: pointer;
  }
  .slider::-moz-range-thumb {
    display: inline-block;
    width: 25px;
    height: 25px;
    background: #4CAF50;
    cursor: pointer;
  }
</style>
<svg width="1400" height="600"></svg>
<div class="ui-section">
  <label><span class="key">Unique Collisions:</span> <span id="unique-collisions">0</span></label>
</div>
<div class="ui-section">
<label><span class="key">Total Collisions-Time Instances:</span> <spane id="total-collisions">0</spane></label>
</div>
<div class="ui-section">
<label><span class="key">Timescale:</span></label>
<input type="range" min="0.0001" max="5.0" value=".5" step="0.001" class="slider input" id="time-scale-slider">
</div>
<div class="ui-section">
<label><span class="key">Robots:</span></label>
<input type="range" min="2" max="50" value="10" step="1" class="slider input" id="robots-slider">
</div>
<div class="ui-section">
<label><span class="key">Reset:</span></label>
<input type="button" value="Reset" class="input-button input" id="reset-button" onclick="resetSimulation()">
</div>
<div class="ui-section">
<label><span class="key">Pause:</span></label>
<input type="button" value="Pause" class="input-button input" id="reset-button" onclick="pauseSimulation()">
</div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="libraries/d3-delaunay.js"></script>
<script>

/**************************************************
  ******************* Classes **********************
  **************************************************/

function distanceBetween2Points(pos1, pos2){
  return Math.sqrt( (pos1.x - pos2.x) * (pos1.x - pos2.x) + (pos1.y - pos2.y) * (pos1.y - pos2.y));
}

/**************************************************
 ******************* Classes **********************
 **************************************************/

class Renderer{
  constructor(svg, scene){
    this.scene = scene;

    // Create line segments between robots and corresponding goal 
    this.scene.robotToGoalLineSegs = svg.append("g")
            .selectAll("path")
            .data(this.scene.robots)
            .enter()
            .append("path")
            .attr("fill", "none")
            .attr("stroke", (d, i) => d3.schemeCategory10[i % 10])
            .attr("stroke-width", 1)
            .attr("stroke-dasharray","10,10")
            .attr("d", d => this.renderLineSeg(d.position.x, d.position.y, d.goal.x, d.goal.y));

    // Buffered Voronoi cells edges
    this.scene.BvcMesh = svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "#cccccc70")
          .attr("stroke-width", this.scene.radius*2)
          .attr("d", this.scene.voronoi.render());

    // Voronoi cells edges
    this.scene.VcMesh = svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "#000")
          .attr("stroke-width", 1)
          .attr("d", this.scene.voronoi.render());

    // Voronoi cells
    this.scene.vCells = svg.append("g")
          .attr("fill", "none")
          .attr("pointer-events", "all")
          .selectAll("path")
          .data(this.scene.getCurRobotsPos())
          .enter()
          .append("path")
          .attr("d", (d, i) => this.scene.voronoi.renderCell(i));

    // Robots
    this.scene.robotsCircles = svg.append("g")
          .selectAll("circle")
          .data(this.scene.robots)
          .enter()
          .append("circle")
          .attr("cx", d => d.position.x)
          .attr("cy", d => d.position.y)
          .attr("id", d => d.id)
          .attr("r", d => d.radius)
          .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
          .call(d3.drag()
                .on("start", d => this.scene.robotsCircles.filter(p => p.id === d.id).raise().attr("stroke", "black"))
                .on("drag", d => (d.position.x = d3.event.x, d.position.y = d3.event.y))
                .on("end", d => this.scene.robotsCircles.filter(p => p.id === d.id).attr("stroke", null))
                .on("start.update drag.update end.update", this.scene.update));

    // Goals
    this.scene.goalsCircles = svg.append("g")
          .selectAll("circle")
          .data(this.scene.robots)
          .enter()
          .append("circle")
          .attr("cx", d => d.goal.x)
          .attr("cy", d => d.goal.y)
          .attr("id", d => d.id)
          .attr("r", d => d.radius/4)
          .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
          .call(d3.drag()
                .on("start", d => this.scene.goalsCircles.filter(p => p.id === d.id).raise().attr("stroke", "black"))
                .on("drag", d => (d.goal.x = d3.event.x, d.goal.y = d3.event.y))
                .on("end", d => this.scene.goalsCircles.filter(p => p.id === d.id).attr("stroke", null))
                .on("start.update drag.update end.update", this.scene.update));
    
  }

  update(){
    this.scene.vCells.attr("d", (d, i) => this.scene.voronoi.renderCell(i));
    this.scene.robotToGoalLineSegs.attr("d", d => this.renderLineSeg(d.position.x, d.position.y, d.goal.x, d.goal.y));
    this.scene.BvcMesh.attr("d", this.scene.voronoi.render());
    this.scene.VcMesh.attr("d", this.scene.voronoi.render());
    this.scene.robotsCircles.attr("cx", d => d.position.x).attr("cy", d => d.position.y);
    this.scene.goalsCircles.attr("cx", d => d.goal.x).attr("cy", d => d.goal.y);
  }
  
  renderLineSeg(x1,y1,x2,y2){
    return `M${x1},${y1}L${x2},${y2}Z`
  }
}

class Scene{
  constructor(svg, numOfRobots, robotRadius){
    this.svg = svg;
    this.width = svg.attr("width");
    this.height = svg.attr("height");
    this.numOfRobots = numOfRobots;
    this.radius = robotRadius;
    this.collisionFreePositions = this.getCollisionFreePositions(this.numOfRobots, this.radius, this.width, this.height);

    // Initialize Robots
    this.robots = this.initializeRobotsRange(this.numOfRobots, this.radius, this.width, this.height);

    // Initialize Voronoi Diagram
    this.voronoi = Delaunay
      .from(this.getCurRobotsPos(), d => d.x, d => d.y)
      .voronoi([0, 0, this.width, this.height]);
    
    // Initialize Renderer
    this.renderer = new Renderer(svg, this);

    // Simulation Speed
    this.timeScale = 0.1;

    // Collision Detection
    this.uniqueCollisions = [];
    this.totalCollisionTimeInst = 0;
  }

  setTimeScale(scale){
    this.timeScale = scale/10;
  }

  update(){
    // TODO: find alternative to using global gScene here instead of "this"
    // Using "this" is causing errors when update() is being called from svg on drag and drop oprations
    gScene.robots.forEach(r => r.timeStep(gScene.timeScale));

    gScene.checkCollision(false);

    gScene.voronoi = Delaunay
       .from(gScene.getCurRobotsPos(), d => d.x, d => d.y)
       .voronoi([0, 0, gScene.width, gScene.height]);

    gScene.renderer.update();
  }

  checkCollision(preventCollision = false){
    let detectedCollisions = [];

    this.robots.forEach((r,i) => {
        r.getCollisionsAgainstRobots(this.robots.slice(i+1), 0).forEach(d => detectedCollisions.push(d))
      });
   
    if(detectedCollisions.length > 0){
      this.totalCollisionTimeInst += detectedCollisions.length;
      detectedCollisions.forEach(d => this.pushUniqueCollisions(this.uniqueCollisions,d));
      //console.log(this.totalCollisionTimeInst, detectedCollisions, this.uniqueCollisions);
    }
  }

  pushUniqueCollisions(collisionsArray, newCollision){
    if(collisionsArray.findIndex(x => x[0]==newCollision[0] && x[1]==newCollision[1])==-1){
      collisionsArray.push(newCollision);
    }
  }

  getCurRobotsPos(){
    return this.robots.map(r => r.position);
  }

  getCurGoalsPos(){
    return this.robots.map(r => r.goal);
  }

  initializeRobotsRange(numOfRobots, radius, envWidth, envHeight){
    return  d3.range(numOfRobots)
              .map(i => new Robot(  i,
                                    this.getRandCollisionFreePos(),
                                    this.getRandCollisionFreePos(),
                                    radius,
                                    envWidth,
                                    envHeight));    
  }

  getRandCollisionFreePos(){
    return this.collisionFreePositions.pop();
  }

  getCollisionFreePositions(numOfRobots, radius, envWidth, envHeight){
    const resolution = (radius*2.1);
    let xCount = envWidth / resolution;
    let yCount = envHeight / resolution;

    if(xCount*yCount<numOfRobots*4){
      throw "Invalid inputs, number and size of robots are too high for this environment size!"
    }

    let positions = [];
    let i = 0;
    while (positions.length<numOfRobots*3  && i<numOfRobots*100) {
      const newX = Math.max(radius,Math.min(envWidth-radius,Math.floor(Math.random()*xCount)*resolution));
      const newY = Math.max(radius,Math.min(envHeight-radius,Math.floor(Math.random()*yCount)*resolution));
      const newPos = {x:newX, y:newY};

      if(positions.findIndex(x => distanceBetween2Points(x,newPos)<radius*2.5) == -1){
        positions.push(newPos);
      }      
      i++;
    }
    
    if(positions.length<numOfRobots*2){
      throw "Invalid inputs, number and size of robots are too high for this environment size!"
    }

    //console.log(positions);
    return positions;
  }
}

class Robot{
  constructor(id, position, goal, radius, envWidth, envHeight){
    // configs
    this.MovementGoals = { Random: 0, 
                          GoalStraight: 1, 
                          GoalWithCollisionAvoidance: 2 };

    this.id = id;
    this.position = position;
    this.prevPosition = position;
    this.goal = goal;
    this.radius = radius;
    this.envWidth = envWidth;
    this.envHeight = envHeight;

    // Initialize velocity according to movement goal
    this.velocity = {x: 0, y: 0};
    this.setMovementGoal(this.MovementGoals.GoalStraight);

  }

  timeStep(timeDelta){
    this.updateVelocity();
    this.limitGoal();
    this.prevPosition = this.position;
    this.position = this.limitPos({   x: this.position.x + this.velocity.x * timeDelta,
                                      y: this.position.y + this.velocity.y * timeDelta});
  }

  setMovementGoal(movementGoal){
    this.movementGoal = movementGoal;

    switch (this.movementGoal ) {
      case this.MovementGoals.Random:
        this.velocity = {x: (Math.random()-0.5) * this.radius, y: (Math.random()-0.5) * this.radius};
        break;
      default:
        this.updateVelocity();
        break;
    }
  }

  updateVelocity(){
    switch (this.movementGoal) {
      case this.MovementGoals.Random:
        // should not change random speed at each time step to avoid vibrating in place 
        break;
      case this.MovementGoals.GoalStraight:
        this.setVelocityStraightToGoal();
        break;
      default:
        break;
    }
  }

  setVelocityStraightToGoal(){
    if(this.reachedGoal()){
      this.velocity = {x:0, y:0};
    } else{
      const xDiff = this.goal.x - this.position.x;
      const yDiff = this.goal.y - this.position.y;

      // this.velocity.x = Math.max( Math.abs(xDiff/20), this.radius/2);
      // this.velocity.y = Math.max( Math.abs(yDiff/20), this.radius/2);

      // this.velocity.x *= Math.sign(xDiff);
      // this.velocity.y *= Math.sign(yDiff);
      
      this.velocity.x = xDiff/20;
      this.velocity.y = yDiff/20;
    }
  }

  reachedGoal(){
    return this.getDistanceToGoal() <= this.radius/10;
  }

  getDistanceToGoal(){
    return distanceBetween2Points(this.position, this.goal);
  }

  limitPos(position){
    const radius = this.radius;
    this.velocity.x = position.x <= radius || position.x >= this.envWidth-radius ? this.velocity.x * -1 : this.velocity.x; 
    this.velocity.y = position.y <= radius || position.y >= this.envHeight-radius ? this.velocity.y * -1 : this.velocity.y;

    return {  x: Math.min( Math.max(radius, position.x), this.envWidth-radius),
              y: Math.min( Math.max(radius, position.y), this.envHeight-radius)};
  }

  limitGoal(){
    const radius = this.radius;
    this.goal = {   x: Math.min( Math.max(radius, this.goal.x), this.envWidth-radius),
                    y: Math.min( Math.max(radius, this.goal.y), this.envHeight-radius)};  
  }

  collidingWithRobot(r){
    return distanceBetween2Points(this.position,r.position) < this.radius*2;
  }

  getCollisionsAgainstRobots(robots, prevent=false){
    let collisions = [];
    robots.forEach(r => {
      if(this.collidingWithRobot(r)){
        collisions.push([Math.min(this.id, r.id), Math.max(this.id, r.id)]);
      }
    });
    return collisions;
  }
}

// Setup
var paused = false;
var numberOfRobots = 80;
var radiusOfRobots = 10;
var svg = d3.select("svg");
var gScene = new Scene(svg, numberOfRobots, radiusOfRobots);

var resetSimulation = function(){
  svg.selectAll("*").remove();
  gScene = new Scene(svg, numberOfRobots, radiusOfRobots);
}

var pauseSimulation= function(){
  paused = !paused;
}

var renderScene = function(){
  if(!paused){
    gScene.update();  
  }

  numberOfRobots = document.getElementById("robots-slider").value
  gScene.setTimeScale(document.getElementById("time-scale-slider").value);
  document.getElementById("unique-collisions").textContent = gScene.uniqueCollisions.length;
  document.getElementById("total-collisions").textContent = gScene.totalCollisionTimeInst;

  requestAnimationFrame(renderScene);
}

renderScene();

</script>
