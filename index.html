<!DOCTYPE html>
<meta charset="utf-8">
<style>

</style>
<svg width="960" height="500"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="libraries/d3-delaunay.js"></script>
<script>

/**************************************************
 ************* Helper Functions *******************
 **************************************************/

function getRandRobotPos(numOfRobots, radiusOfRobots, envWidth, envHeight){
  return d3.range(numOfRobots).map(i => ({
    x: Math.random() * (envWidth - radiusOfRobots * 2) + radiusOfRobots,
    y: Math.random() * (envHeight - radiusOfRobots * 2) + radiusOfRobots,
  }))
}

function renderLineSeg(x1,y1,x2,y2){
  return `M${x1},${y1}L${x2},${y2}Z`
}

/**************************************************
 ************* Voronoi Diagram ********************
 **************************************************/

// Canvas setup
var svg = d3.select("svg");
var width = svg.attr("width");
var height = svg.attr("height");

// Robors Setup
var numOfRobots = 5;
var radius = 20;
var robotPositions = getRandRobotPos(numOfRobots,radius,width,height);
var goalPositions = getRandRobotPos(numOfRobots,radius,width,height);
var robotToGoalLineSegs = [];

// Create line segments between robots and corresponding goal 
robotPositions.forEach( (el,i) => {
  robotToGoalLineSegs.push(svg.append("path")
        .attr("fill", "none")
        .attr("stroke", d3.schemeCategory10[i % 10])
        .attr("stroke-width", 1)
        .attr("stroke-dasharray","10,10")
        .attr("d", renderLineSeg(el.x,el.y,goalPositions[i].x,goalPositions[i].y)));
});

// Voronoi setup
var voronoi = Delaunay
  .from(robotPositions, d => d.x, d => d.y)
  .voronoi([0, 0, width, height]);

// Buffered Voronoi cells edges
var BvcMesh = svg.append("path")
      .attr("fill", "none")
      .attr("stroke", "#cccccc70")
      .attr("stroke-width", radius*2)
      .attr("d", voronoi.render());

// Voronoi cells edges
var VcMesh = svg.append("path")
      .attr("fill", "none")
      .attr("stroke", "#000")
      .attr("stroke-width", 1)
      .attr("d", voronoi.render());

// Voronoi cells
var vCells = svg.append("g")
      .attr("fill", "none")
      .attr("pointer-events", "all")
      .selectAll("path")
      .data(robotPositions)
      .enter()
      .append("path")
      .attr("d", (d, i) => voronoi.renderCell(i));

// Robots
var robotsCircles = svg.append("g")
      .selectAll("circle")
      .data(robotPositions)
      .enter()
      .append("circle")
      .attr("cx", d => d.x)
      .attr("cy", d => d.y)
      .attr("r", radius)
      .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
      .call(d3.drag()
            .on("start", d => circle.filter(p => p === d).raise().attr("stroke", "black"))
            .on("drag", d => (d.x = d3.event.x, d.y = d3.event.y))
            .on("end", d => circle.filter(p => p === d).attr("stroke", null))
            .on("start.update drag.update end.update", update));

// Goals
var goalsCircles = svg.append("g")
      .selectAll("circle")
      .data(goalPositions)
      .enter()
      .append("circle")
      .attr("cx", d => d.x)
      .attr("cy", d => d.y)
      .attr("r", 5)
      .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
      .call(d3.drag()
            .on("start", d => circle.filter(p => p === d).raise().attr("stroke", "black"))
            .on("drag", d => (d.x = d3.event.x, d.y = d3.event.y))
            .on("end", d => circle.filter(p => p === d).attr("stroke", null))
            .on("start.update drag.update end.update", update));

function update() {
  voronoi = Delaunay.from(robotPositions, d => d.x, d => d.y).voronoi([0, 0, width, height]);
  vCells.attr("d", (d, i) => voronoi.renderCell(i));
  robotToGoalLineSegs.forEach( (el,i) => {
        el.attr("d", renderLineSeg(robotPositions[i].x,robotPositions[i].y,goalPositions[i].x,goalPositions[i].y))
        });
  BvcMesh.attr("d", voronoi.render());
  VcMesh.attr("d", voronoi.render());
  robotsCircles.attr("cx", d => d.x).attr("cy", d => d.y);
}
</script>
