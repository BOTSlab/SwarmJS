<!DOCTYPE html>
<meta charset="utf-8">
<style>

</style>
<svg width="1600" height="1200"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="libraries/d3-delaunay.js"></script>
<script>

/**************************************************
 ******************* Classes **********************
 **************************************************/

class Renderer{
  constructor(svg, scene){
    this.scene = scene;

    // Create line segments between robots and corresponding goal 
    this.scene.robotToGoalLineSegs = svg.append("g")
            .selectAll("path")
            .data(this.scene.robots)
            .enter()
            .append("path")
            .attr("fill", "none")
            .attr("stroke", (d, i) => d3.schemeCategory10[i % 10])
            .attr("stroke-width", 1)
            .attr("stroke-dasharray","10,10")
            .attr("d", d => this.renderLineSeg(d.position.x, d.position.y, d.goal.x, d.goal.y));

    // Buffered Voronoi cells edges
    this.scene.BvcMesh = svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "#cccccc70")
          .attr("stroke-width", this.scene.radius*2)
          .attr("d", this.scene.voronoi.render());

    // Voronoi cells edges
    this.scene.VcMesh = svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "#000")
          .attr("stroke-width", 1)
          .attr("d", this.scene.voronoi.render());

    // Voronoi cells
    this.scene.vCells = svg.append("g")
          .attr("fill", "none")
          .attr("pointer-events", "all")
          .selectAll("path")
          .data(this.scene.getCurRobotsPos())
          .enter()
          .append("path")
          .attr("d", (d, i) => this.scene.voronoi.renderCell(i));

    // Robots
    this.scene.robotsCircles = svg.append("g")
          .selectAll("circle")
          .data(this.scene.robots)
          .enter()
          .append("circle")
          .attr("cx", d => d.position.x)
          .attr("cy", d => d.position.y)
          .attr("id", d => d.id)
          .attr("r", d => d.radius)
          .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
          .call(d3.drag()
                .on("start", d => this.scene.robotsCircles.filter(p => p.id === d.id).raise().attr("stroke", "black"))
                .on("drag", d => (d.position.x = d3.event.x, d.position.y = d3.event.y))
                .on("end", d => this.scene.robotsCircles.filter(p => p.id === d.id).attr("stroke", null))
                .on("start.update drag.update end.update", this.scene.update));

    // Goals
    this.scene.goalsCircles = svg.append("g")
          .selectAll("circle")
          .data(this.scene.robots)
          .enter()
          .append("circle")
          .attr("cx", d => d.goal.x)
          .attr("cy", d => d.goal.y)
          .attr("id", d => d.id)
          .attr("r", d => d.radius/4)
          .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
          .call(d3.drag()
                .on("start", d => this.scene.goalsCircles.filter(p => p.id === d.id).raise().attr("stroke", "black"))
                .on("drag", d => (d.goal.x = d3.event.x, d.goal.y = d3.event.y))
                .on("end", d => this.scene.goalsCircles.filter(p => p.id === d.id).attr("stroke", null))
                .on("start.update drag.update end.update", this.scene.update));
    
  }

  update(){
    this.scene.vCells.attr("d", (d, i) => this.scene.voronoi.renderCell(i));
    this.scene.robotToGoalLineSegs.attr("d", d => this.renderLineSeg(d.position.x, d.position.y, d.goal.x, d.goal.y));
    this.scene.BvcMesh.attr("d", this.scene.voronoi.render());
    this.scene.VcMesh.attr("d", this.scene.voronoi.render());
    this.scene.robotsCircles.attr("cx", d => d.position.x).attr("cy", d => d.position.y);
    this.scene.goalsCircles.attr("cx", d => d.goal.x).attr("cy", d => d.goal.y);
  }
  
  renderLineSeg(x1,y1,x2,y2){
    return `M${x1},${y1}L${x2},${y2}Z`
  }
}

class Scene{
  constructor(svg, numOfRobots, robotRadius){
    this.svg = svg;
    this.width = svg.attr("width");
    this.height = svg.attr("height");
    this.numOfRobots = numOfRobots;
    this.radius = robotRadius;

    // Initialize Robots
    this.robots = this.initializeRobotsRange(this.numOfRobots, this.radius, this.width, this.height);

    // Initialize Voronoi Diagram
    this.voronoi = Delaunay
      .from(this.getCurRobotsPos(), d => d.x, d => d.y)
      .voronoi([0, 0, this.width, this.height]);
    
    // Initialize Renderer
    this.renderer = new Renderer(svg, this);

    // Simulation Speed
    this.timeScale = 1;
  }

  setTimeScale(scale){
    this.timeScale = scale;
  }

  update(){
    // TODO: find alternative to using global gScene here instead of "this"
    // Using "this" is causing errors when update() is being called from svg on drag and drop oprations
    gScene.robots.forEach(r => r.timeStep(gScene.timeScale));

    gScene.voronoi = Delaunay
       .from(gScene.getCurRobotsPos(), d => d.x, d => d.y)
       .voronoi([0, 0, gScene.width, gScene.height]);

    gScene.renderer.update();
  }

  getCurRobotsPos(){
    return this.robots.map(r => r.position);
  }

  getCurGoalsPos(){
    return this.robots.map(r => r.goal);
  }

  initializeRobotsRange(numOfRobots, radius, envWidth, envHeight){
    return  d3.range(numOfRobots)
              .map(i => new Robot(  i,
                                    this.getRandSafePos(radius, envWidth, envHeight),
                                    this.getRandSafePos(radius, envWidth, envHeight),
                                    radius,
                                    envWidth,
                                    envHeight));    
  }

  getRandSafePos(radius, envWidth, envHeight){
    return {  x: Math.random() * (envWidth - radius * 2) + radius,
              y: Math.random() * (envHeight - radius * 2) + radius};
  }

  getRandSafePosRange(range, radius, envWidth, envHeight){
    return d3.range(range).map(i => this.getRandSafePos(radius, envWidth, envHeight));
  }
}

class Robot{
  constructor(id, position, goal, radius, envWidth, envHeight){
    // configs
    this.MovementGoals = { Random: 0, 
                          GoalStraight: 1, 
                          GoalWithCollisionAvoidance: 2 };

    this.id = id;
    this.position = position;
    this.goal = goal;
    this.radius = radius;
    this.envWidth = envWidth;
    this.envHeight = envHeight;

    this.movementGoal = this.MovementGoals.Random;
    this.setMovement(this.movementGoal);

  }

  timeStep(timeDelta){
    this.position = this.limitPos({   x: this.position.x + this.velocity.x * timeDelta,
                                      y: this.position.y + this.velocity.y * timeDelta});
  }

  setMovement(movementGoal){
    let vel = {};

    if(movementGoal == this.MovementGoals.Random){
      vel = {x: (Math.random()-0.5) * this.radius, y: (Math.random()-0.5) * this.radius};
    }

    this.velocity = vel;
  }

  limitPos(position){
    this.velocity.x = position.x < 0 || position.x > this.envWidth ? this.velocity.x * -1 : this.velocity.x; 
    this.velocity.y = position.y < 0 || position.y > this.envHeight ? this.velocity.y * -1 : this.velocity.y; 

    return {  x: Math.min( Math.max(0, position.x), this.envWidth),
              y: Math.min( Math.max(0, position.y), this.envHeight)};
  }
}

// Setup
var svg = d3.select("svg");
var gScene = new Scene(svg, 50, 20);
gScene.setTimeScale(0.2);

var renderScene = function(){
  gScene.update();

  requestAnimationFrame(renderScene);
}

renderScene();

</script>
