<!DOCTYPE html>
<meta charset="utf-8">
<style>

</style>
<svg width="960" height="500"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="libraries/d3-delaunay.js"></script>
<script>

/**************************************************
 ******************* Classes **********************
 **************************************************/

class Renderer{
  constructor(svg, scene){
    this.scene = scene;

    // Create line segments between robots and corresponding goal 
    this.scene.robotToGoalLineSegs = svg.append("g")
            .selectAll("path")
            .data(this.scene.robots)
            .enter()
            .append("path")
            .attr("fill", "none")
            .attr("stroke", (d, i) => d3.schemeCategory10[i % 10])
            .attr("stroke-width", 1)
            .attr("stroke-dasharray","10,10")
            .attr("d", d => this.renderLineSeg(d.position.x, d.position.y, d.goal.x, d.goal.y));

    // Buffered Voronoi cells edges
    this.scene.BvcMesh = svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "#cccccc70")
          .attr("stroke-width", this.scene.radius*2)
          .attr("d", this.scene.voronoi.render());

    // Voronoi cells edges
    this.scene.VcMesh = svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "#000")
          .attr("stroke-width", 1)
          .attr("d", this.scene.voronoi.render());

    // Voronoi cells
    this.scene.vCells = svg.append("g")
          .attr("fill", "none")
          .attr("pointer-events", "all")
          .selectAll("path")
          .data(this.scene.getCurRobotsPos())
          .enter()
          .append("path")
          .attr("d", (d, i) => this.scene.voronoi.renderCell(i));

    // Robots
    this.scene.robotsCircles = svg.append("g")
          .selectAll("circle")
          .data(this.scene.robots)
          .enter()
          .append("circle")
          .attr("cx", d => d.position.x)
          .attr("cy", d => d.position.y)
          .attr("id", d => d.id)
          .attr("r", d => d.radius)
          .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
          .call(d3.drag()
                .on("start", d => this.scene.robotsCircles.filter(p => p.id === d.id).raise().attr("stroke", "black"))
                .on("drag", d => (d.position.x = d3.event.x, d.position.y = d3.event.y))
                .on("end", d => this.scene.robotsCircles.filter(p => p.id === d.id).attr("stroke", null))
                .on("start.update drag.update end.update", this.scene.update));

    // Goals
    this.scene.goalsCircles = svg.append("g")
          .selectAll("circle")
          .data(this.scene.robots)
          .enter()
          .append("circle")
          .attr("cx", d => d.goal.x)
          .attr("cy", d => d.goal.y)
          .attr("id", d => d.id)
          .attr("r", d => d.radius/4)
          .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
          .call(d3.drag()
                .on("start", d => this.scene.goalsCircles.filter(p => p.id === d.id).raise().attr("stroke", "black"))
                .on("drag", d => (d.goal.x = d3.event.x, d.goal.y = d3.event.y))
                .on("end", d => this.scene.goalsCircles.filter(p => p.id === d.id).attr("stroke", null))
                .on("start.update drag.update end.update", this.scene.update));
    
  }

  update(){
    this.scene.vCells.attr("d", (d, i) => this.scene.voronoi.renderCell(i));
    this.scene.robotToGoalLineSegs.attr("d", d => this.renderLineSeg(d.position.x, d.position.y, d.goal.x, d.goal.y));
    this.scene.BvcMesh.attr("d", this.scene.voronoi.render());
    this.scene.VcMesh.attr("d", this.scene.voronoi.render());
    this.scene.robotsCircles.attr("cx", d => d.position.x).attr("cy", d => d.position.y);
    this.scene.goalsCircles.attr("cx", d => d.goal.x).attr("cy", d => d.goal.y);
  }
  
  renderLineSeg(x1,y1,x2,y2){
    return `M${x1},${y1}L${x2},${y2}Z`
  }
}

class Scene{
  constructor(svg, numOfRobots, robotRadius){
    this.svg = svg;
    this.width = svg.attr("width");
    this.height = svg.attr("height");
    this.numOfRobots = numOfRobots;
    this.radius = robotRadius;

    // Initialize Robots
    this.robots = this.initializeRobotsRange(this.numOfRobots, this.radius, this.width, this.height);

    // Initialize Voronoi Diagram
    this.voronoi = Delaunay
      .from(this.getCurRobotsPos(), d => d.x, d => d.y)
      .voronoi([0, 0, this.width, this.height]);
    
    // Initialize Renderer
    this.renderer = new Renderer(svg, this);
  }

  update(){
    // TODO: find alternative to using global gScene here instead of "this"
    // Using "this" is causing errors when update() is being called from svg on drag and drop oprations
    gScene.voronoi = Delaunay
       .from(gScene.getCurRobotsPos(), d => d.x, d => d.y)
       .voronoi([0, 0, gScene.width, gScene.height]);

    gScene.renderer.update();
  }

  getCurRobotsPos(){
    return this.robots.map(r => r.position);
  }

  getCurGoalsPos(){
    return this.robots.map(r => r.goal);
  }

  initializeRobotsRange(numOfRobots, radius, envWidth, envHeight){
    return  d3.range(numOfRobots)
              .map(i => new Robot(  i,
                                    this.getRandSafePos(radius, envWidth, envHeight),
                                    this.getRandSafePos(radius, envWidth, envHeight),
                                    radius));    
  }

  getRandSafePos(radius, envWidth, envHeight){
    return {  x: Math.random() * (envWidth - radius * 2) + radius,
              y: Math.random() * (envHeight - radius * 2) + radius};
  }

  getRandSafePosRange(range, radius, envWidth, envHeight){
    return d3.range(range).map(i => this.getRandSafePos(radius, envWidth, envHeight));
  }
}

class Robot{
  constructor(id, position=[0,0], goal=[0,0], radius=5){
    this.id = id;
    this.position = position;
    this.goal = goal;
    this.radius = radius;
  }
}

// Setup
var svg = d3.select("svg");
var gScene = new Scene(svg, 5, 20);

</script>
