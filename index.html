<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body{
    font-size: 1.2em;
    font-family: serif;
  }
  .options{
    text-align: center;
  }
  .ui-section{
    position: relative;
    min-height: 35px;
    padding: 2PX;
  }
  .key{
    display: inline-block;
    position: absolute;
    top: 2px;
    left: 40px;
    width: 300px;
    color: #34a21a;
    font-weight: 700;
    line-height: 25px;
  }
  .input {
    width: 40%;
    margin: 0px;
    background: #e7e7e7;
    outline: none;
    -webkit-transition: .2s;
    transition: opacity .2s;
  }
  .input:hover {
    opacity: .8;
  }
  .input-text{
    text-align: center;
    border: none;
  }
  .input-button, .input-select, .input-text{
    color: #4CAF50;
    font-size: 0.8em;
    font-weight: bold;
    border: none;
    height: 25PX;
    margin-left: 2px;
    text-align-last:center;
  }
  .input-button:active{
    background-color: #5b5b5b;
  }
  .slider{
    -webkit-appearance: none;
    height: 25px;
  }
  .slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 25px;
    height: 25px;
    background: #4CAF50;
    cursor: pointer;
  }
  .slider::-moz-range-thumb {
    display: inline-block;
    width: 25px;
    height: 25px;
    background: #4CAF50;
    cursor: pointer;
  }
  @media only screen and (max-width: 1023px) {
    .ui-section{
      min-height: 70px;
    }
    .key {
    display: block;
    position: inherit;
    }
  }
</style>
<svg width="1400" height="600"></svg>
<div class="options">
  <div class="ui-section">
    <label class="key">Unique Collisions:</label>
    <input type="text" class="input-text input" id="unique-collisions" disabled>
  </div>
  <div class="ui-section">
    <label class="key">Total Collisions-Time Instances:</label>
    <input type="text" class="input-text input" id="total-collisions" disabled>
  </div>
  <div class="ui-section">
    <label class="key">Timescale:</label>
    <input type="range" min="0.0001" max="1.0" value=".005" step="0.001" class="slider input" id="time-scale-slider">
  </div>
  <div class="ui-section">
    <label class="key">Robots:</label>
    <input type="range" min="2" max="50" value="10" step="1" class="slider input" id="robots-slider">
  </div>
  <div class="ui-section">
    <label class="key">Montion Planning Algorithm:</label>
    <select class="input-select input" id="algorithm-select" name="algorithms">
      <!-- <option value="0">Random</option> -->
      <option value="1">None (Straight To Goal)</option>
      <option value="2">Voronoi Cell</option>
      <option value="3" selected>Buffered Voronoi Cell</option>
    </select>
  </div>
  <div class="ui-section">
    <label class="key">Reset:</label>
    <input type="button" value="Reset" class="input-button input" id="reset-button" onclick="resetSimulation()">
  </div>
  <div class="ui-section">
    <label class="key">Pause:</label>
    <input type="button" value="Pause" class="input-button input" id="reset-button" onclick="pauseSimulation()">
  </div>
</div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="libraries/d3-delaunay.js"></script>
<script>

/**************************************************
 *************** Helper Functions *****************
 **************************************************/

function nxtCircIndx(i,length){
  return (i+1)%length;
}

function closestPointInLineSegToPoint(x, y, x1, y1, x2, y2) {
  var A = x - x1;
  var B = y - y1;
  var C = x2 - x1;
  var D = y2 - y1;

  var dot = A * C + B * D;
  var len_sq = C * C + D * D;
  var param = -1;
  if (len_sq != 0) //in case of 0 length line
      param = dot / len_sq;

  var xx, yy;

  if (param < 0) {
    xx = x1;
    yy = y1;
  }
  else if (param > 1) {
    xx = x2;
    yy = y2;
  }
  else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  return {x:xx, y:yy};
}

function distanceBetween2Points(pos1, pos2){
  var ret =  Math.sqrt( (pos1.x - pos2.x) * (pos1.x - pos2.x) + (pos1.y - pos2.y) * (pos1.y - pos2.y));
  return ret;
}


function distanceBetweenPointAndLineSeg(point, point1LineSeg, point2LineSeg){
  var ret =  distanceBetween2Points(point, closestPointInLineSegToPoint(point.x, point.y, point1LineSeg.x, point1LineSeg.y, point2LineSeg.x, point2LineSeg.y));
  return ret;
}

function midPointOfLineSeg(x1, y1, x2, y2){
  return {x:(x1+x2)/2, y: (y1+y2)/2};
}

function slopeOfLineSeg(x1, y1, x2, y2){
  if((x2-x1)==0){
    return 99999999999;
  }
  return (y2-y1)/(x2-x1);
}

function slopeOfPerpendicularBisectorOfLineSeg(x1, y1, x2, y2){
  return -1/slopeOfLineSeg(x1, y1, x2, y2);
}

function directionOfPerpendicularBisector(x1, y1, x2, y2, scale){
  let length = distanceBetween2Points({x:x1,y:y1},{x:x2,y:y2});
  return {x:scale*(y1-y2)/length, y:scale*(x2-x1)/length};
}

function translatePointInDirection(x1, y1, xVec, yVec){
  return {x:x1+xVec, y:y1+yVec};
}

function shiftPointOfLineSegInDirOfPerpendicularBisector(x, y, x1, y1, x2, y2, scale){
  let dir = directionOfPerpendicularBisector(x1, y1, x2, y2, scale);
  let p1 = translatePointInDirection(x, y, dir.x, dir.y);
  return p1;
}

function shiftLineSegInDirOfPerpendicularBisector(x1, y1, x2, y2, scale){
  let dir = directionOfPerpendicularBisector(x1, y1, x2, y2, scale);
  let p1 = translatePointInDirection(x1, y1, dir.x, dir.y);
  let p2 = translatePointInDirection(x2, y2, dir.x, dir.y);
  return [p1,p2];
}

function getIntersectionPoint(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
    var denominator, a, b, numerator1, numerator2, result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
    };
    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
    if (denominator == 0) {
        return result;
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    // if we cast these lines infinitely in both directions, they intersect here:
    result.x = line1StartX + (a * (line1EndX - line1StartX));
    result.y = line1StartY + (a * (line1EndY - line1StartY));
/*
        // it is worth noting that this should be the same as:
        x = line2StartX + (b * (line2EndX - line2StartX));
        y = line2StartX + (b * (line2EndY - line2StartY));
        */
    // if line1 is a segment and line2 is infinite, they intersect if:
    if (a > 0 && a < 1) {
        result.onLine1 = true;
    }
    // if line2 is a segment and line1 is infinite, they intersect if:
    if (b > 0 && b < 1) {
        result.onLine2 = true;
    }
    // if line1 and line2 are segments, they intersect if both of the above are true
    return result;
};

/**************************************************
 ******************* Classes **********************
 **************************************************/

class Renderer{
  constructor(svg, scene){
    this.svg = svg;
    this.scene = scene;
    this.scene.BVCLineSegs = [];

    // Create line segments between robots and corresponding goal 
    this.scene.robotToGoalLineSegs = svg.append("g")
            .selectAll("path")
            .data(this.scene.robots)
            .enter()
            .append("path")
            .attr("fill", "none")
            .attr("stroke", (d, i) => d3.schemeCategory10[i % 10])
            .attr("stroke-width", 1)
            .attr("stroke-dasharray","10,10")
            .attr("d", d => this.renderLineSeg(d.position.x, d.position.y, d.goal.x, d.goal.y));

    // Create line segments between robots and corresponding temp goal 
    this.scene.robotToTempGoalLineSegs = svg.append("g")
            .selectAll("path")
            .data(this.scene.robots)
            .enter()
            .append("path")
            .attr("fill", "none")
            .attr("stroke", (d, i) => d3.schemeCategory10[i % 10])
            .attr("stroke-width", 1)
            .attr("stroke-dasharray","1,10")
            .attr("d", d => this.renderLineSeg(d.position.x, d.position.y, d.tempGoal.x, d.tempGoal.y));
            
    // Create line segments between each robot's temp goal and goal 
    this.scene.tempGoalToGoalLineSegs = svg.append("g")
            .selectAll("path")
            .data(this.scene.robots)
            .enter()
            .append("path")
            .attr("fill", "none")
            .attr("stroke", (d, i) => d3.schemeCategory10[i % 10])
            .attr("stroke-width", 1)
            .attr("stroke-dasharray","1,10")
            .attr("d", d => this.renderLineSeg(d.tempGoal.x, d.tempGoal.y, d.goal.x, d.goal.y));

    // Buffered Voronoi cells edges
    this.scene.BvcMesh = svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "#cccccc70")
          .attr("stroke-width", this.scene.radius*2)
          .attr("d", this.scene.voronoi.render());

    // Voronoi cells edges
    this.scene.VcMesh = svg.append("path")
          .attr("fill", "none")
          .attr("stroke", "#000")
          .attr("stroke-width", 1)
          .attr("d", this.scene.voronoi.render());

    // Voronoi cells
    this.scene.vCells = svg.append("g")
          .attr("fill", "none")
          .attr("pointer-events", "all")
          .selectAll("path")
          .data(this.scene.getCurRobotsPos())
          .enter()
          .append("path")
          .attr("d", (d, i) => this.scene.voronoi.renderCell(i));

    // Robots
    this.scene.robotsCircles = svg.append("g")
          .selectAll("circle")
          .data(this.scene.robots)
          .enter()
          .append("circle")
          .attr("cx", d => d.position.x)
          .attr("cy", d => d.position.y)
          .attr("id", d => d.id)
          .attr("r", d => d.radius)
          .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
          .call(d3.drag()
                .on("start", d => this.scene.robotsCircles.filter(p => p.id === d.id).raise().attr("stroke", "black"))
                .on("drag", d => (d.position.x = d3.event.x, d.position.y = d3.event.y))
                .on("end", d => this.scene.robotsCircles.filter(p => p.id === d.id).attr("stroke", null))
                .on("start.update drag.update end.update", this.scene.update));

    // Temp Goals
    this.scene.tempGoalsCircles = svg.append("g")
          .attr("fill-opacity", "40%")
          .attr("stroke-width", 1)
          .attr("stroke-dasharray","1,1")
          .selectAll("circle")
          .data(this.scene.robots)
          .enter()
          .append("circle")
          .attr("cx", d => d.tempGoal.x)
          .attr("cy", d => d.tempGoal.y)
          .attr("id", d => d.id)
          .attr("r", d => d.radius/1.5)
          .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
          .attr("stroke",  (d, i) => d3.schemeCategory10[i % 10]);
    
    // Goals
    this.scene.goalsCircles = svg.append("g")
          .selectAll("circle")
          .data(this.scene.robots)
          .enter()
          .append("circle")
          .attr("cx", d => d.goal.x)
          .attr("cy", d => d.goal.y)
          .attr("id", d => d.id)
          .attr("r", d => d.radius/4)
          .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
          .call(d3.drag()
                .on("start", d => this.scene.goalsCircles.filter(p => p.id === d.id).raise().attr("stroke", "black"))
                .on("drag", d => (d.goal.x = d3.event.x, d.goal.y = d3.event.y))
                .on("end", d => this.scene.goalsCircles.filter(p => p.id === d.id).attr("stroke", null))
                .on("start.update drag.update end.update", this.scene.update));
    
  }

  update(){
    this.svg.selectAll(".bvc-seg").remove();
    this.scene.BVCLineSegs = [];
    this.scene.robots.forEach((r,rIndex) => {
      //console.log(r);
      if(typeof(r.BVC) !== "undefined" && r.BVC.length>0){
        // Create line segments between robots and corresponding goal 
        //console.log(r.BVC);
        this.scene.BVCLineSegs.push(this.svg.append("g")
                .selectAll("path")
                .data(r.BVC)
                .enter()
                .append("path")
                .attr("class", "bvc-seg")
                .attr("fill", "none")
                .attr("stroke", (d, i) => d3.schemeCategory10[rIndex % 10])
                .attr("stroke-width", 1)
                .attr("stroke-dasharray","10,10")
                .attr("d", (d,i) => this.renderLineSeg(r.BVC[i][0], r.BVC[i][1], r.BVC[nxtCircIndx(i,r.BVC.length)][0], r.BVC[nxtCircIndx(i,r.BVC.length)][1]))
                );
      } else{
        //console.log("null");        
      }
    });   

    this.scene.vCells.attr("d", (d, i) => this.scene.voronoi.renderCell(i));
    this.scene.robotToGoalLineSegs.attr("d", d => this.renderLineSeg(d.position.x, d.position.y, d.goal.x, d.goal.y));
    this.scene.robotToTempGoalLineSegs.attr("d", d => this.renderLineSeg(d.position.x, d.position.y, d.tempGoal.x, d.tempGoal.y));
    this.scene.tempGoalToGoalLineSegs.attr("d", d => this.renderLineSeg(d.tempGoal.x, d.tempGoal.y, d.goal.x, d.goal.y));
    this.scene.BvcMesh.attr("d", this.scene.voronoi.render());
    this.scene.VcMesh.attr("d", this.scene.voronoi.render());
    this.scene.robotsCircles.attr("cx", d => d.position.x).attr("cy", d => d.position.y);
    this.scene.tempGoalsCircles.attr("cx", d => d.tempGoal.x).attr("cy", d => d.tempGoal.y);
    this.scene.goalsCircles.attr("cx", d => d.goal.x).attr("cy", d => d.goal.y);
  }
  
  renderLineSeg(x1,y1,x2,y2){
    return `M${x1},${y1}L${x2},${y2}Z`
  }
}

class Scene{
  constructor(svg, numOfRobots, robotRadius, motionPlanningAlgorithm){
    this.svg = svg;
    this.width = svg.attr("width");
    this.height = svg.attr("height");
    this.numOfRobots = numOfRobots;
    this.radius = robotRadius;
    this.collisionFreePositions = this.getCollisionFreePositions(this.numOfRobots, this.radius, this.width, this.height);

    // Initialize Robots
    this.robots = this.initializeRobotsRange(this.numOfRobots, this.radius, this.width, this.height, motionPlanningAlgorithm);

    // Initialize Voronoi Diagram
    this.voronoi = Delaunay
      .from(this.getCurRobotsPos(), d => d.x, d => d.y)
      .voronoi([0, 0, this.width, this.height]);
    
    // Initialize Renderer
    this.renderer = new Renderer(svg, this);

    // Simulation Speed
    this.timeScale = 0.1;

    // Collision Detection
    this.uniqueCollisions = [];
    this.totalCollisionTimeInst = 0;
  }

  setTimeScale(scale){
    this.timeScale = scale/10;
  }

  update(){
    // TODO: find alternative to using global gScene here instead of "this"
    // Using "this" is causing errors when update() is being called from svg on drag and drop oprations
    gScene.updateRobotsMeasurements();

    gScene.robots.forEach(r => r.timeStep(gScene.timeScale));

    gScene.checkCollision(false);

    gScene.voronoi = Delaunay
       .from(gScene.getCurRobotsPos(), d => d.x, d => d.y)
       .voronoi([0, 0, gScene.width, gScene.height]);

    gScene.renderer.update();
  }

  updateRobotsMeasurements(){
    this.robots.forEach((r,i) => {
      let cell = this.voronoi.cellPolygon(i);
      r.VC = cell;
      
      let shiftedLineSegs = [];

      for (let index = 0; index < cell.length-1; index++) {
        let lineSeg = [cell[index], cell[index+1]];
        let shiftedLineSeg = shiftLineSegInDirOfPerpendicularBisector(lineSeg[0][0], lineSeg[0][1], lineSeg[1][0], lineSeg[1][1], r.radius*1.2);
        shiftedLineSegs.push(shiftedLineSeg);
      }

      let BVC = [];
      let skipNext = false;

      for (let index = 0; index < shiftedLineSegs.length; index++) {
        if(skipNext){
          skipNext = false;
          continue;
        }
        let vcIndx = index;
        let vcIndx2 = nxtCircIndx(vcIndx,shiftedLineSegs.length);
        let vcIndx3 = nxtCircIndx(vcIndx2,shiftedLineSegs.length);

        let vcLineSeg1 = [{x:cell[vcIndx][0], y:cell[vcIndx][1]}, {x:cell[vcIndx2][0], y:cell[vcIndx2][1]}];

        let lineSeg1 = shiftedLineSegs[vcIndx];
        let lineSeg2 = shiftedLineSegs[vcIndx2];
        let lineSeg3 = shiftedLineSegs[vcIndx3];

        let intersectionPoint = getIntersectionPoint( lineSeg1[0].x, lineSeg1[0].y, lineSeg1[1].x, lineSeg1[1].y,
                                                      lineSeg2[0].x, lineSeg2[0].y, lineSeg2[1].x, lineSeg2[1].y);

        let intersectionPoint2 = getIntersectionPoint( lineSeg2[0].x, lineSeg2[0].y, lineSeg2[1].x, lineSeg2[1].y,
                                                      lineSeg3[0].x, lineSeg3[0].y, lineSeg3[1].x, lineSeg3[1].y);

        let dist1 = distanceBetweenPointAndLineSeg(intersectionPoint, vcLineSeg1[0], vcLineSeg1[1]);
        let dist2 = distanceBetweenPointAndLineSeg(intersectionPoint2, vcLineSeg1[0], vcLineSeg1[1]);
        let cond = dist2 < dist1;

        if(shiftedLineSegs.length > 3 && cond){
          // console.log("error");
          BVC.push([intersectionPoint2.x, intersectionPoint2.y]);
          skipNext = true;
        }else{
          BVC.push([intersectionPoint.x, intersectionPoint.y]);
        }
      }    
      
      r.BVC = BVC;

      //console.log(r,i,this.voronoi.cellPolygon(i));
      //r.neighbors = Array.from(this.voronoi.neighbors(i)).map(i=> this.robots[i]);
      //console.log(r,i,Array.from(this.voronoi.neighbors(i)).map(i=> this.robots[i]));
    })
  }

  checkCollision(preventCollision = false){
    let detectedCollisions = [];

    this.robots.forEach((r,i) => {
        r.getCollisionsAgainstRobots(this.robots.slice(i+1), 0).forEach(d => detectedCollisions.push(d))
      });
   
    if(detectedCollisions.length > 0){
      this.totalCollisionTimeInst += detectedCollisions.length;
      detectedCollisions.forEach(d => this.pushUniqueCollisions(this.uniqueCollisions,d));
      //console.log(this.totalCollisionTimeInst, detectedCollisions, this.uniqueCollisions);
    }
  }

  pushUniqueCollisions(collisionsArray, newCollision){
    if(collisionsArray.findIndex(x => x[0]==newCollision[0] && x[1]==newCollision[1])==-1){
      collisionsArray.push(newCollision);
    }
  }

  getCurRobotsPos(){
    return this.robots.map(r => r.position);
  }

  getCurGoalsPos(){
    return this.robots.map(r => r.goal);
  }

  initializeRobotsRange(numOfRobots, radius, envWidth, envHeight, motionPlanningAlgorithm){
    return  d3.range(numOfRobots)
              .map(i => new Robot(  i,
                                    this.getRandCollisionFreePos(),
                                    this.getRandCollisionFreePos(),
                                    radius,
                                    envWidth,
                                    envHeight,
                                    this,
                                    motionPlanningAlgorithm));    
  }

  getRandCollisionFreePos(){
    return this.collisionFreePositions.pop();
  }

  getCollisionFreePositions(numOfRobots, radius, envWidth, envHeight){
    const resolution = (radius*2.1);
    let xCount = envWidth / resolution;
    let yCount = envHeight / resolution;

    if(xCount*yCount<numOfRobots*4){
      throw "Invalid inputs, number and size of robots are too high for this environment size!"
    }

    let positions = [];
    let i = 0;
    while (positions.length<numOfRobots*3  && i<numOfRobots*100) {
      const newX = Math.max(radius,Math.min(envWidth-radius,Math.floor(Math.random()*xCount)*resolution));
      const newY = Math.max(radius,Math.min(envHeight-radius,Math.floor(Math.random()*yCount)*resolution));
      const newPos = {x:newX, y:newY};

      if(positions.findIndex(x => distanceBetween2Points(x,newPos)<radius*2.5) == -1){
        positions.push(newPos);
      }      
      i++;
    }
    
    if(positions.length<numOfRobots*2){
      throw "Invalid inputs, number and size of robots are too high for this environment size!"
    }

    //console.log(positions);
    return positions;
  }
}

class Robot{
  constructor(id, position, goal, radius, envWidth, envHeight, scene, motionPlanningAlgorithm){
    // configs
    this.MovementGoals = { Random: 0, 
                          GoalStraight: 1, 
                          GoalWithVC: 2 , 
                          GoalWithBVC: 3 };

    this.id = id;
    this.position = position;
    this.prevPosition = position;
    this.goal = goal;
    this.tempGoal = null;
    this.radius = radius;
    this.envWidth = envWidth;
    this.envHeight = envHeight;
    this.scene = scene;
    this.VC = [];

    // Initialize velocity according to movement goal
    this.velocity = {x: 0, y: 0};
    this.setMovementGoal(motionPlanningAlgorithm);

  }

  timeStep(timeDelta){
    this.updateVelocity();
    this.limitGoal();
    this.prevPosition = this.position;
    this.position = this.limitPos({   x: this.position.x + this.velocity.x * timeDelta,
                                      y: this.position.y + this.velocity.y * timeDelta});
  }

  setMovementGoal(movementGoal){
    this.movementGoal = movementGoal;

    switch (this.movementGoal ) {
      case this.MovementGoals.Random:
        this.tempGoal = this.goal;
        this.velocity = {x: (Math.random()-0.5) * this.radius, y: (Math.random()-0.5) * this.radius};
        break;
      case this.MovementGoals.GoalStraight:
        this.tempGoal = this.goal;
        this.updateVelocity();
        break;
      case this.MovementGoals.GoalWithVC:
        this.setTempGoalVC(this.VC);
        this.updateVelocity();
        break;
      case this.MovementGoals.GoalWithBVC:
        this.setTempGoalVC(this.BVC);
        this.updateVelocity();
        break;
      default:
        this.tempGoal = this.goal;
        this.updateVelocity();
        break;
    }
  }

  updateVelocity(){
    switch (this.movementGoal) {
      case this.MovementGoals.Random:
        this.tempGoal = this.goal;
        // should not change random speed at each time step to avoid vibrating in place 
        break;
      case this.MovementGoals.GoalStraight:
        this.tempGoal = this.goal;
        this.setVelocityTo(this.goal);
        break;
      case this.MovementGoals.GoalWithVC:
        this.setTempGoalVC(this.VC);
        this.setVelocityTo(this.tempGoal,3);
        break;
      case this.MovementGoals.GoalWithBVC:
        this.setTempGoalVC(this.BVC);
        this.setVelocityTo(this.tempGoal,3);
        break;
      default:
        this.tempGoal = this.goal;
        break;
    }
  }

  setVelocityTo(point, velocityScale = 20){
    if(this.reached(point)){
      this.velocity = {x:0, y:0};
    } else{
      const xDiff = point.x - this.position.x;
      const yDiff = point.y - this.position.y;

      // this.velocity.x = Math.max( Math.abs(xDiff/20), this.radius/2);
      // this.velocity.y = Math.max( Math.abs(yDiff/20), this.radius/2);

      // this.velocity.x *= Math.sign(xDiff);
      // this.velocity.y *= Math.sign(yDiff);
      
      this.velocity.x = xDiff/velocityScale;
      this.velocity.y = yDiff/velocityScale;
    }
  }

  setTempGoalVC(cell){
    if(this.VcContains(this.goal)){
      this.tempGoal = this.goal;
      return;
    }
    
    if(cell == null || cell.length<2){
      this.tempGoal = this.goal;
      return;
    }

    var tempG = null;
    var minDist = null;

    // cell.forEach(vertex => {
    //   let distGoalToVertex = distanceBetween2Points(this.goal,{x:vertex[0], y:vertex[1]});
    //   if(tempG==null || distGoalToVertex < minDist){
    //     tempG = {x:vertex[0], y:vertex[1]};
    //     minDist = distGoalToVertex;
    //   } 
    // });

    for (let index = 0; index < cell.length-1; index++) {
      const v1 = cell[index];
      const v2 = cell[index+1];
      let closestPointInLineSeg = closestPointInLineSegToPoint(this.goal.x, this.goal.y, v1[0], v1[1], v2[0], v2[1]);

      let distGoalToLineSeg = distanceBetween2Points(this.goal, closestPointInLineSeg);
      
      if(tempG==null || distGoalToLineSeg < minDist){
        tempG = {x:closestPointInLineSeg.x, y:closestPointInLineSeg.y};
        minDist = distGoalToLineSeg;
      }
    }

    this.tempGoal = tempG;
  }

  VcContains(point){
    return typeof(this.scene.voronoi) !== "undefined" && this.scene.voronoi != null && 
        this.scene.voronoi.contains(this.id, point.x, point.y);
  }

  reached(point){
    var ret = this.getDistanceTo(point) <= this.radius/10
    return ret;
  }

  getDistanceTo(point){
    var ret =  distanceBetween2Points(this.position, point);
    return ret;
  }

  limitPos(position){
    const radius = this.radius;
    this.velocity.x = position.x <= radius || position.x >= this.envWidth-radius ? this.velocity.x * -1 : this.velocity.x; 
    this.velocity.y = position.y <= radius || position.y >= this.envHeight-radius ? this.velocity.y * -1 : this.velocity.y;

    return {  x: Math.min( Math.max(radius, position.x), this.envWidth-radius),
              y: Math.min( Math.max(radius, position.y), this.envHeight-radius)};
  }

  limitGoal(){
    const radius = this.radius;
    this.goal = {   x: Math.min( Math.max(radius, this.goal.x), this.envWidth-radius),
                    y: Math.min( Math.max(radius, this.goal.y), this.envHeight-radius)};  
  }

  collidingWithRobot(r){
    return distanceBetween2Points(this.position,r.position) < this.radius*2;
  }

  getCollisionsAgainstRobots(robots, prevent=false){
    let collisions = [];
    robots.forEach(r => {
      if(this.collidingWithRobot(r)){
        collisions.push([Math.min(this.id, r.id), Math.max(this.id, r.id)]);
      }
    });
    return collisions;
  }
}

// var res = shiftLineSegInDirOfPerpendicularBisector(0,0,1,1);
// console.log(res);
// throw new Error("Something went badly wrong!");

// Setup
var paused = false;
var numberOfRobots = 2;
var radiusOfRobots = 10;
var svg = d3.select("svg");
let motionPlanningAlgorithm = parseInt(document.getElementById("algorithm-select").value);
var gScene = new Scene(svg, numberOfRobots, radiusOfRobots, motionPlanningAlgorithm);

var resetSimulation = function(){
  svg.selectAll("*").remove();
  motionPlanningAlgorithm = parseInt(document.getElementById("algorithm-select").value);
  gScene = new Scene(svg, numberOfRobots, radiusOfRobots, motionPlanningAlgorithm);
}

var pauseSimulation= function(){
  paused = !paused;
}

var renderScene = function(){
  if(!paused){
    gScene.update();  
  }

  numberOfRobots = document.getElementById("robots-slider").value;
  gScene.setTimeScale(document.getElementById("time-scale-slider").value);
  document.getElementById("unique-collisions").value = gScene.uniqueCollisions.length;
  document.getElementById("total-collisions").value = gScene.totalCollisionTimeInst;

  requestAnimationFrame(renderScene);
}

renderScene();

</script>
